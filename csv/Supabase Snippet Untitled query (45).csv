query,calls,total_exec_time,mean_exec_time,rows
"COPY (
  WITH used_tables(schema_name, table_name, must_have, should_have) AS (
    VALUES
      ('public','games',                ARRAY['id']::text[],                     ARRAY['status','state','current_day']::text[]),
      ('public','players',              ARRAY['id','game_id','user_id','role']::text[], ARRAY['name','is_active','is_gm','last_seen','left_at','status']::text[]),
      ('public','player_ready',         ARRAY['game_id','role','day','ready']::text[],  ARRAY['updated_at']::text[]),
      ('public','decisions',            ARRAY['id','game_id']::text[],           ARRAY['current_day','kpi_values','settings','features']::text[]),
      ('public','events',               ARRAY['game_id','day']::text[],          ARRAY['type','content','timestamp']::text[]),
      ('public','game_state_snapshots', ARRAY['game_id','day','state']::text[],  ARRAY['kpi','decisions','timestamp','criteria','type']::text[]),
      ('public','game_credit_history',  ARRAY['game_id','day','amount']::text[], ARRAY['role','interest_rate','created_at']::text[]),
      ('public','trainer_memberships',  ARRAY['game_id','user_id']::text[],      ARRAY[]::text[]),
      ('public','trainer_hints',        ARRAY['game_id','player_id','message']::text[], ARRAY['sender_uid','sent_at']::text[]),
      ('public','game_admin_settings',  ARRAY['game_id','settings']::text[],     ARRAY['seed','features']::text[])
  ),
  -- (restlicher Query-Block wie oben, identisch)
  meta AS (SELECT u.schema_name, u.table_name, u.must_have, u.should_have, to_regclass(u.schema_name||'.'||u.table_name) AS regclass FROM used_tables u),
  cols AS (SELECT m.schema_name, m.table_name, array_agg(c.column_name ORDER BY c.ordinal_position) AS actual_columns FROM meta m LEFT JOIN information_schema.columns c ON c.table_schema = m.schema_name AND c.table_name  = m.table_name GROUP BY 1,2),
  pkeys AS (SELECT n.nspname AS schema_name, c.relname AS table_name, array_agg(a.attname ORDER BY a.attnum) FILTER (WHERE i.indisprimary) AS pk_columns FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace LEFT JOIN pg_index i ON i.indrelid = c.oid AND i.indisprimary LEFT JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(i.indkey) WHERE n.nspname='public' AND c.relkind='r' GROUP BY 1,2),
  uniq  AS (SELECT schemaname AS schema_name, tablename  AS table_name, array_agg(indexname || ' => ' || indexdef ORDER BY indexname) FILTER (WHERE indexdef ILIKE '%UNIQUE%') AS unique_indexes FROM pg_indexes WHERE schemaname='public' GROUP BY 1,2),
  rls   AS (SELECT n.nspname AS schema_name, c.relname AS table_name, c.relrowsecurity AS rls_enabled, (SELECT count(*) FROM pg_policies p WHERE p.schemaname=n.nspname AND p.tablename=c.relname) AS policy_count FROM pg_class c JOIN pg_namespace n ON n.oid=c.relnamespace WHERE n.nspname='public' AND c.relkind='r'),
  size  AS (SELECT n.nspname AS schema_name, c.relname AS table_name, c.reltuples::bigint AS row_estimate FROM pg_class c JOIN pg_namespace n ON n.oid=c.relnamespace WHERE n.nspname='public' AND c.relkind='r')
  SELECT
    m.schema_name, m.table_name, (m.regclass IS NOT NULL) AS table_exists, s.row_estimate,
    r.rls_enabled, r.policy_count, pk.pk_columns, u.unique_indexes,
    coalesce(c.actual_columns, ARRAY[]::text[]) AS actual_columns,
    m.must_have, m.should_have,
    ARRAY(SELECT x FROM unnest(m.must_have)  x EXCEPT SELECT y FROM unnest(coalesce(c.actual_columns, ARRAY[]::text[])) y) AS missing_must_have,
    ARRAY(SELECT x FROM unnest(m.should_have) x EXCEPT SELECT y FROM unnest(coalesce(c.actual_columns, ARRAY[]::text[])) y) AS missing_should_have
  FROM meta m
  LEFT JOIN cols  c USING (schema_name, table_name)
  LEFT JOIN pkeys pk USING (schema_name, table_name)
  LEFT JOIN uniq  u USING (schema_name, table_name)
  LEFT JOIN rls   r USING (schema_name, table_name)
  LEFT JOIN size  s USING (schema_name, table_name)
  ORDER BY m.table_name
) TO STDOUT WITH CSV HEADER",1,143.046497,143.046497,10
"-- =====================================================================
-- AUDIT v5 (asserting, fehlerfrei): bricht mit klarer Meldung ab,
-- wenn eine Bedingung nicht erfüllt ist.
-- =====================================================================
DO $$
DECLARE 
  v_cnt int;
  v_typ text;
BEGIN
  -- games.join_code existiert?
  SELECT COUNT(*) INTO v_cnt
  FROM information_schema.columns
  WHERE table_schema='public' AND table_name='games' AND column_name='join_code';
  IF v_cnt = 0 THEN 
    RAISE EXCEPTION 'AUDIT: games.join_code fehlt.'; 
  END IF;

  -- join_code ist uuid?
  SELECT data_type INTO v_typ
  FROM information_schema.columns
  WHERE table_schema='public' AND table_name='games' AND column_name='join_code';
  IF v_typ <> 'uuid' THEN 
    RAISE EXCEPTION 'AUDIT: games.join_code ist % statt uuid.', v_typ; 
  END IF;

  -- join_code: keine NULLs
  SELECT COUNT(*) INTO v_cnt FROM public.games WHERE join_code IS NULL;
  IF v_cnt <> 0 THEN 
    RAISE EXCEPTION 'AUDIT: games.join_code enthält % NULLs.', v_cnt; 
  END IF;

  -- join_code: keine Duplikate (case-insensitiv; bei uuid äquivalent)
  SELECT COUNT(*) - COUNT(DISTINCT LOWER(join_code::text)) INTO v_cnt FROM public.games;
  IF v_cnt <> 0 THEN 
    RAISE EXCEPTION 'AUDIT: games.join_code enthält Duplikate (%).', v_cnt; 
  END IF;

  -- Unique-Index auf join_code vorhanden?
  SELECT COUNT(*) INTO v_cnt
  FROM pg_index idx
  JOIN pg_class i ON i.oid = idx.indexrelid
  JOIN pg_class t ON t.oid = idx.indrelid
  JOIN pg_namespace n ON n.oid = t.relnamespace
  WHERE n.nspname='public' AND t.relname='games' AND idx.indisunique
    AND pg_get_indexdef(idx.indexrelid) ILIKE '%(join_code)%';
  IF v_cnt = 0 THEN 
    RAISE EXCEPTION 'AUDIT: Unique-Index auf games(join_code) fehlt.'; 
  END IF;

  -- players Unique-Index (game_id,user_id)
  SELECT COUNT(*) INTO v_cnt
  FROM pg_index idx
  JOIN pg_class i ON i.oid = idx.indexrelid
  JOIN pg_class t ON t.oid = idx.indrelid
  JOIN pg_namespace n ON n.oid = t.relnamespace
  WHERE n.nspname='public' AND t.relname='players' AND idx.indisunique
    AND pg_get_indexdef(idx.indexrelid) ILIKE '%(game_id, user_id)%';
  IF v_cnt = 0 THEN 
    RAISE EXCEPTION 'AUDIT: Unique-Index players(game_id,user_id) fehlt.'; 
  END IF;

  -- decisions.player_id → players.id vorhanden?
  SELECT COUNT(*) INTO v_cnt
  FROM information_schema.table_constraints tc
  JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name AND tc.table_schema = kcu.table_schema
  JOIN information_schema.constraint_column_usage ccu ON ccu.constraint_name = tc.constraint_name AND ccu.table_schema = tc.table_schema
  WHERE tc.constraint_type='FOREIGN KEY' AND tc.table_schema='public' AND tc.table_name='decisions' AND ccu.table_name='players' AND kcu.column_name='player_id';
  IF v_cnt = 0 THEN 
    RAISE EXCEPTION 'AUDIT: FK decisions.player_id → players.id fehlt.'; 
  END IF;

  -- RLS aktiv auf Kern-Tabellen?
  SELECT COUNT(*) INTO v_cnt FROM pg_class c JOIN pg_namespace n ON n.oid=c.relnamespace
   WHERE n.nspname='public' AND c.relname IN ('games','players','trainer_memberships') AND c.relrowsecurity IS TRUE;
  IF v_cnt <> 3 THEN 
    RAISE EXCEPTION 'AUDIT: RLS nicht auf allen Kern-Tabellen aktiv.'; 
  END IF;

  -- players-Policies dürfen NICHT games referenzieren (keine Rekursion)
  SELECT COUNT(*) INTO v_cnt
  FROM pg_policies
  WHERE schemaname='public' AND tablename='players'
    AND (qual ILIKE '%games.%' OR qual ILIKE '% FROM games %' OR with_check ILIKE '%games.%' OR with_check ILIKE '% FROM games %');
  IF v_cnt <> 0 THEN 
    RAISE EXCEPTION 'AUDIT: players-Policies referenzieren games (Rekursion!).'; 
  END IF;

  -- RPC join_game vorhanden & SECURITY INVOKER
  SELECT COUNT(*) INTO v_cnt
  FROM pg_proc p JOIN pg_namespace n ON n.oid = p.pronamespace
  WHERE n.nspname='public' AND p.proname='join_game' AND p.prosecdef = FALSE;
  IF v_cnt = 0 THEN 
    RAISE EXCEPTION 'AUDIT: RPC join_game(uuid) fehlt oder ist nicht SECURITY INVOKER.'; 
  END IF;

  RAISE NOTICE 'AUDIT OK: Alle Checks erfolgreich.';
END$$",2,62.067927,31.0339635,0
"-- 2.3.1 Trainer-Membership: NEU (vermeidet Rekursion auf players)
CREATE TABLE IF NOT EXISTS public.trainer_memberships (
  game_id   uuid NOT NULL REFERENCES public.games(id) ON DELETE CASCADE,
  user_id   uuid NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (game_id, user_id)
)",3,33.187513,11.0625043333333,0
"-- 2.2: Policies für trainer_memberships (INSERT/SELECT/DELETE)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname='public' AND tablename='trainer_memberships' AND policyname='tm_insert_self_if_trainer_or_gm'
  ) THEN
    EXECUTE $sql$
      CREATE POLICY tm_insert_self_if_trainer_or_gm
      ON public.trainer_memberships
      FOR INSERT TO authenticated
      WITH CHECK (
        user_id = auth.uid()
        AND EXISTS (
          SELECT 1 FROM public.players p
          WHERE p.game_id = trainer_memberships.game_id
            AND p.user_id = auth.uid()
            AND (p.role = 'TRAINER' OR p.is_gm = true)
        )
      );
    $sql$;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname='public' AND tablename='trainer_memberships' AND policyname='tm_select_same_game_member'
  ) THEN
    EXECUTE $sql$
      CREATE POLICY tm_select_same_game_member
      ON public.trainer_memberships
      FOR SELECT TO authenticated
      USING (
        EXISTS (
          SELECT 1 FROM public.players p
          WHERE p.game_id = trainer_memberships.game_id
            AND p.user_id = auth.uid()
        )
      );
    $sql$;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname='public' AND tablename='trainer_memberships' AND policyname='tm_delete_gm_only'
  ) THEN
    EXECUTE $sql$
      CREATE POLICY tm_delete_gm_only
      ON public.trainer_memberships
      FOR DELETE TO authenticated
      USING (
        EXISTS (
          SELECT 1 FROM public.players p
          WHERE p.game_id = trainer_memberships.game_id
            AND p.user_id = auth.uid()
            AND p.is_gm = true
        )
      );
    $sql$;
  END IF;
END $$",1,25.91931,25.91931,0
ALTER TABLE public.trainer_memberships ENABLE ROW LEVEL SECURITY,8,24.06644,3.008305,0
"WITH pgrst_source AS (INSERT INTO ""public"".""trainer_memberships""(""game_id"", ""user_id"") SELECT ""pgrst_body"".""game_id"", ""pgrst_body"".""user_id"" FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""game_id"", ""user_id"" FROM json_to_record(pgrst_payload.json_data) AS _(""game_id"" uuid, ""user_id"" uuid) ) pgrst_body WHERE set_config($2, (coalesce(nullif(current_setting($3, $4), $5)::int, $6) + $7)::text, $8) <> $9 ON CONFLICT(""game_id"", ""user_id"") DO UPDATE SET ""game_id"" = EXCLUDED.""game_id"", ""user_id"" = EXCLUDED.""user_id""WHERE set_config($10, (coalesce(nullif(current_setting($11, $12), $13)::int, $14) - $15)::text, $16) <> $17 RETURNING $18) SELECT $19 AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, array[]::text[] AS header, $20::text AS body, nullif(current_setting($21, $22), $23) AS response_headers, nullif(current_setting($24, $25), $26) AS response_status, nullif(current_setting($27, $28),$29)::int AS response_inserted FROM (SELECT * FROM pgrst_source) _postgrest_t",8,14.957744,1.869718,8
"-- ============================================================================
-- 8) TRAINER_MEMBERSHIPS: Unique-Index + nicht-rekursive RLS-Policies
-- ============================================================================
DO $$
BEGIN
  IF to_regclass('public.trainer_memberships') IS NOT NULL THEN
    -- Spalten sollten per FK-Liste existieren (game_id,user_id). Index:
    CREATE UNIQUE INDEX IF NOT EXISTS trainer_memberships_game_user_uidx
      ON public.trainer_memberships(game_id, user_id);

    -- RLS aktiv (idempotent)
    ALTER TABLE public.trainer_memberships ENABLE ROW LEVEL SECURITY;

    -- Bestehende Policies mit unseren Namen entfernen (falls vorhanden)
    DROP POLICY IF EXISTS tm_select_self ON public.trainer_memberships;
    DROP POLICY IF EXISTS tm_insert_self ON public.trainer_memberships;
    DROP POLICY IF EXISTS tm_update_self ON public.trainer_memberships;
    DROP POLICY IF EXISTS tm_delete_self ON public.trainer_memberships;

    -- Selbstentkoppelte Policies (keine Fremdtabellen! keine Rekursion!)
    CREATE POLICY tm_select_self ON public.trainer_memberships
      FOR SELECT USING (user_id = auth.uid());

    CREATE POLICY tm_insert_self ON public.trainer_memberships
      FOR INSERT WITH CHECK (user_id = auth.uid());

    CREATE POLICY tm_update_self ON public.trainer_memberships
      FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

    CREATE POLICY tm_delete_self ON public.trainer_memberships
      FOR DELETE USING (user_id = auth.uid());
  END IF;
END$$",1,13.037695,13.037695,0
"-- SELECT: (a) Absender*in, (b) adressierte Spieler-Identität, (c) Trainer/in des Spiels
do $$
begin
  if exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='players' and column_name='user_id'
  ) then
    execute $POL$
      create policy th_select_member_or_trainer
        on public.trainer_hints
        for select
        to authenticated
        using (
          sender_uid = auth.uid()
          or exists (
            select 1 from public.players p
            where p.id = trainer_hints.player_id
              and p.game_id = trainer_hints.game_id
              and p.user_id = auth.uid()
          )
          or exists (
            select 1 from public.trainer_memberships t
            where t.game_id = trainer_hints.game_id
              and t.user_id = auth.uid()
          )
        )
    $POL$;
  elsif exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='players' and column_name='auth_uid'
  ) then
    execute $POL$
      create policy th_select_member_or_trainer
        on public.trainer_hints
        for select
        to authenticated
        using (
          sender_uid = auth.uid()
          or exists (
            select 1 from public.players p
            where p.id = trainer_hints.player_id
              and p.game_id = trainer_hints.game_id
              and p.auth_uid = auth.uid()
          )
          or exists (
            select 1 from public.trainer_memberships t
            where t.game_id = trainer_hints.game_id
              and t.user_id = auth.uid()
          )
        )
    $POL$;
  else
    -- Fallback: Kein Mapping Spieler <-> auth.uid() vorhanden -> nur Trainer-Sicht + Absender*in
    execute $POL$
      create policy th_select_trainer_only
        on public.trainer_hints
        for select
        to authenticated
        using (
          sender_uid = auth.uid()
          or exists (
            select 1 from public.trainer_memberships t
            where t.game_id = trainer_hints.game_id
              and t.user_id = auth.uid()
          )
        )
    $POL$;
  end if;
end$$",2,13.037457,6.5187285,0
"-- ============================================================================
-- 10) GAMES: Lobby-Lesepolicy + selektive Sicht (Creator, Mitglied, Trainer)
--      (keine Rekursion, da players nicht mehr auf games verweist)
-- ============================================================================
DO $$
BEGIN
  IF to_regclass('public.games') IS NOT NULL THEN
    ALTER TABLE public.games ENABLE ROW LEVEL SECURITY;

    -- Nur unsere Policy-Namen manipulieren
    DROP POLICY IF EXISTS games_select_lobby_any                  ON public.games;
    DROP POLICY IF EXISTS games_select_creator_member_trainer     ON public.games;
    DROP POLICY IF EXISTS games_insert_self                       ON public.games;
    DROP POLICY IF EXISTS games_update_creator                    ON public.games;

    -- Lobby ist für anon & authenticated lesbar (nur state-Filter, keine Fremdtabellen)
    CREATE POLICY games_select_lobby_any ON public.games
      FOR SELECT TO anon, authenticated
      USING (state = 'lobby');

    -- Creator, Mitglied (players), Trainer (trainer_memberships) dürfen lesen
    CREATE POLICY games_select_creator_member_trainer ON public.games
      FOR SELECT
      USING (
        created_by = auth.uid()
        OR EXISTS (SELECT 1 FROM public.players              p  WHERE p.game_id = games.id AND p.user_id = auth.uid())
        OR EXISTS (SELECT 1 FROM public.trainer_memberships tm WHERE tm.game_id = games.id AND tm.user_id = auth.uid())
        OR state = 'lobby'
      );

    -- Insert/Update: nur Ersteller
    CREATE POLICY games_insert_self ON public.games
      FOR INSERT WITH CHECK (created_by = auth.uid());

    CREATE POLICY games_update_creator ON public.games
      FOR UPDATE USING (created_by = auth.uid()) WITH CHECK (created_by = auth.uid());
  END IF;
END$$",1,12.58549,12.58549,0
"-- games
DO $$
DECLARE pol record;
BEGIN
  IF to_regclass('public.games') IS NOT NULL THEN
    ALTER TABLE public.games ENABLE ROW LEVEL SECURITY;

    FOR pol IN
      SELECT policyname FROM pg_policies
      WHERE schemaname='public' AND tablename='games'
    LOOP
      EXECUTE format('DROP POLICY IF EXISTS %I ON public.games;', pol.policyname);
    END LOOP;

    -- Lobby lesbar (auch ohne Login) – nötig für öffentlichen Join/Lookup
    CREATE POLICY games_select_lobby_any ON public.games
      FOR SELECT TO anon, authenticated
      USING (state = 'lobby');

    -- Creator, Mitglied, Trainer dürfen lesen (einseitig → keine Rekursion)
    CREATE POLICY games_select_creator_member_trainer ON public.games
      FOR SELECT
      USING (
        created_by = auth.uid()
        OR EXISTS (SELECT 1 FROM public.players              p  WHERE p.game_id = games.id AND p.user_id = auth.uid())
        OR EXISTS (SELECT 1 FROM public.trainer_memberships tm WHERE tm.game_id = games.id AND tm.user_id = auth.uid())
        OR state = 'lobby'
      );

    CREATE POLICY games_insert_self ON public.games
      FOR INSERT WITH CHECK (created_by = auth.uid());

    CREATE POLICY games_update_creator ON public.games
      FOR UPDATE USING (created_by = auth.uid()) WITH CHECK (created_by = auth.uid());
  END IF;
END$$",1,11.454215,11.454215,0
"-- ---------------------------------------------------------
-- 1) trainer_memberships: Alle Policies entfernen (namenunabhängig)
--    und minimal, nicht-rekursiv neu erstellen.
--    WICHTIG: KEINE Referenzen auf games/players/etc.
-- ---------------------------------------------------------
DO $$
DECLARE pol record;
BEGIN
  FOR pol IN
    SELECT policyname
    FROM pg_policies
    WHERE schemaname = 'public' AND tablename = 'trainer_memberships'
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS %I ON public.trainer_memberships;', pol.policyname);
  END LOOP;
END$$",1,11.407946,11.407946,0
"-- SELECT: Spielende und Trainer*in desselben Spiels dürfen lesen
CREATE POLICY th_select_member_or_trainer ON public.trainer_hints
  FOR SELECT TO authenticated
  USING (
    EXISTS (SELECT 1 FROM public.players p WHERE p.game_id = trainer_hints.game_id AND p.user_id = auth.uid())
    OR EXISTS (SELECT 1 FROM public.trainer_memberships t WHERE t.game_id = trainer_hints.game_id AND t.user_id = auth.uid())
  )",4,11.215885,2.80397125,0
"-- ============================================================================
-- 9) RLS-Policies — zirkelfrei & robust
--    Wir entfernen ALLE Policies auf den Kern-Tabellen und legen neu an.
-- ============================================================================
-- trainer_memberships
DO $$
DECLARE pol record;
BEGIN
  IF to_regclass('public.trainer_memberships') IS NOT NULL THEN
    ALTER TABLE public.trainer_memberships ENABLE ROW LEVEL SECURITY;

    FOR pol IN
      SELECT policyname FROM pg_policies
      WHERE schemaname='public' AND tablename='trainer_memberships'
    LOOP
      EXECUTE format('DROP POLICY IF EXISTS %I ON public.trainer_memberships;', pol.policyname);
    END LOOP;

    -- Unique-Index & Policies ohne Fremdtabellen (keine Rekursion)
    CREATE UNIQUE INDEX IF NOT EXISTS trainer_memberships_game_user_uidx
      ON public.trainer_memberships(game_id, user_id);

    CREATE POLICY tm_select_self ON public.trainer_memberships
      FOR SELECT USING (user_id = auth.uid());

    CREATE POLICY tm_insert_self ON public.trainer_memberships
      FOR INSERT WITH CHECK (user_id = auth.uid());

    CREATE POLICY tm_update_self ON public.trainer_memberships
      FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

    CREATE POLICY tm_delete_self ON public.trainer_memberships
      FOR DELETE USING (user_id = auth.uid());
  END IF;
END$$",1,10.675357,10.675357,0
"create policy tm_select_own
  on public.trainer_memberships
  for select
  to authenticated
  using (user_id = auth.uid())",2,9.062544,4.531272,0
"create index if not exists trainer_memberships_game_user_idx on public.trainer_memberships (game_id, user_id)",2,8.677154,4.338577,0
"CREATE POLICY players_select_self_or_trainer ON players
FOR SELECT
USING (
  user_id = auth.uid()
  OR EXISTS (
    SELECT 1 FROM trainer_memberships tm
    WHERE tm.user_id = auth.uid()
  )
)",3,8.417642,2.80588066666667,0
"-- 1) Überblick
select
  (select count(*) from public.games) as games,
  (select count(*) from public.players) as players,
  (select count(*) from public.trainer_memberships) as trainer_memberships",1,7.44147,7.44147,1
"-- games
DO $$
DECLARE pol record;
BEGIN
  IF to_regclass('public.games') IS NOT NULL THEN
    ALTER TABLE public.games ENABLE ROW LEVEL SECURITY;
    FOR pol IN SELECT policyname FROM pg_policies WHERE schemaname='public' AND tablename='games'
    LOOP EXECUTE format('DROP POLICY IF EXISTS %I ON public.games;', pol.policyname); END LOOP;

    CREATE POLICY games_select_lobby_any ON public.games
      FOR SELECT TO anon, authenticated
      USING (state = 'lobby');

    CREATE POLICY games_select_creator_member_trainer ON public.games
      FOR SELECT
      USING (
        created_by = auth.uid()
        OR EXISTS (SELECT 1 FROM public.players              p  WHERE p.game_id = games.id AND p.user_id = auth.uid())
        OR EXISTS (SELECT 1 FROM public.trainer_memberships tm WHERE tm.game_id = games.id AND tm.user_id = auth.uid())
        OR state = 'lobby'
      );

    CREATE POLICY games_insert_self ON public.games
      FOR INSERT WITH CHECK (created_by = auth.uid());

    CREATE POLICY games_update_creator ON public.games
      FOR UPDATE USING (created_by = auth.uid()) WITH CHECK (created_by = auth.uid());
  END IF;
END$$",1,6.443603,6.443603,0
"-- 9) RLS — zirkelfrei
-- trainer_memberships
DO $$
DECLARE pol record;
BEGIN
  IF to_regclass('public.trainer_memberships') IS NOT NULL THEN
    ALTER TABLE public.trainer_memberships ENABLE ROW LEVEL SECURITY;
    FOR pol IN SELECT policyname FROM pg_policies WHERE schemaname='public' AND tablename='trainer_memberships'
    LOOP EXECUTE format('DROP POLICY IF EXISTS %I ON public.trainer_memberships;', pol.policyname); END LOOP;

    CREATE UNIQUE INDEX IF NOT EXISTS trainer_memberships_game_user_uidx
      ON public.trainer_memberships(game_id, user_id);

    CREATE POLICY tm_select_self ON public.trainer_memberships
      FOR SELECT USING (user_id = auth.uid());
    CREATE POLICY tm_insert_self ON public.trainer_memberships
      FOR INSERT WITH CHECK (user_id = auth.uid());
    CREATE POLICY tm_update_self ON public.trainer_memberships
      FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());
    CREATE POLICY tm_delete_self ON public.trainer_memberships
      FOR DELETE USING (user_id = auth.uid());
  END IF;
END$$",1,5.63583,5.63583,0
"-- Trainer memberships lookup
CREATE INDEX IF NOT EXISTS idx_trainer_memberships_user 
ON trainer_memberships(user_id)",1,4.643083,4.643083,0